package rdbms

import (
	"fmt"
	"strings"
	"time"

	"github.com/relloyd/halfpipe/constants"
	"github.com/relloyd/halfpipe/logger"
	"github.com/relloyd/halfpipe/rdbms/shared"
	"golang.org/x/net/context"
)

// FAKE DB CONNECTIONS IMPLEMENTING Connector INTERFACE FOR TESTING.

type dbConnectionWithMockDripFeed struct {
	outputChan        chan string // channel to be supplied by caller and used to return SQL and values generated by Exec().
	numRowsToGenerate int
	sleepIntervalSec  int
	dml               shared.DmlGenerator // TODO: implement the mock for this DmlTxtBatcher
	dbType            string
}

func NewDBConnectionWithMockDripFeed(log logger.Logger, numRowsToGenerate int, sleepIntervalSec int, dbType string) (shared.Connector, chan string) {
	log.Debug("New dummy connection with drip feed...")
	outputChan := make(chan string, constants.ChanSize) // output channel so caller can validate input SQL queries.
	return &dbConnectionWithMockDripFeed{
		outputChan:        outputChan,
		numRowsToGenerate: numRowsToGenerate,
		sleepIntervalSec:  sleepIntervalSec,
		dbType:            dbType,
	}, outputChan
}

func (c *dbConnectionWithMockDripFeed) Begin() (shared.Transacter, error) {
	return &txMockedDripFeed{
			outputChan:        c.outputChan,
			numRowsToGenerate: c.numRowsToGenerate,
			sleepIntervalSec:  c.sleepIntervalSec},
		nil // return a dumb txMockedDripFeed that does nothing!
}

func (c *dbConnectionWithMockDripFeed) Exec(query string, args ...interface{}) (shared.Result, error) {
	panic("Unimplemented Exec() in dbConnectionWithMockDripFeed")
	// c.outputChan <- query
	// c.outputChan <- fmt.Sprintf("%v", args...)
	return nil, nil
}

func (c *dbConnectionWithMockDripFeed) ExecContext(ctx context.Context, query string, args ...interface{}) (shared.Result, error) {
	panic("Unimplemented Exec() in dbConnectionWithMockDripFeed")
	return nil, nil
}

func (c *dbConnectionWithMockDripFeed) Query(query string, args ...interface{}) (*shared.HpRows, error) {
	return c.QueryContext(context.Background(), query, args...)
}

func (c *dbConnectionWithMockDripFeed) QueryContext(ctx context.Context, query string, args ...interface{}) (*shared.HpRows, error) {
	// TODO: implement your mock HpRows.
	for idx := 0; idx < c.numRowsToGenerate; idx++ {
		time.Sleep(time.Duration(c.sleepIntervalSec) * time.Second) // sleep for the interval
	}
	return nil, nil
}

func (c *dbConnectionWithMockDripFeed) Close() {
	close(c.outputChan)
}

func (c *dbConnectionWithMockDripFeed) GetDmlGenerator() shared.DmlGenerator {
	return c.dml
}

func (c *dbConnectionWithMockDripFeed) GetType() string {
	return c.dbType
}

type txMockedDripFeed struct {
	outputChan        chan string // channel to be supplied by caller and used to return SQL and values generated by Exec().
	numRowsToGenerate int         // number of rows to emit to outputChan.
	sleepIntervalSec  int         // number of seconds to sleep between emitting rows.
}

func (t *txMockedDripFeed) Prepare(query string) (shared.StatementBatch, error) {
	return t.PrepareContext(context.Background(), query)
}

func (t *txMockedDripFeed) PrepareContext(ctx context.Context, query string) (shared.StatementBatch, error) {
	t.outputChan <- query
	return &stmtMockedDripFeed{}, nil
}

func (t *txMockedDripFeed) Exec(query string, args ...interface{}) (shared.Result, error) {
	return t.ExecContext(context.Background(), query, args...)
}

func (t *txMockedDripFeed) ExecContext(ctx context.Context, query string, args ...interface{}) (shared.Result, error) {
	time.Sleep(time.Duration(t.sleepIntervalSec) * time.Second) // sleep for the interval
	t.outputChan <- query
	format := strings.Repeat("%v ", len(args))
	format = strings.TrimRight(format, " ")
	t.outputChan <- fmt.Sprintf(format, args...)
	return nil, nil
}

func (t *txMockedDripFeed) Commit() error {
	return nil
}

func (t *txMockedDripFeed) Rollback() error {
	return nil
}

type stmtMockedDripFeed struct{}

func (s *stmtMockedDripFeed) ExecBatch(args [][]interface{}) (shared.Result, error) {
	return nil, nil
}
