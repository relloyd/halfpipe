package components

import (
	"fmt"
	"reflect"
	"regexp"
	"sync/atomic"
	"time"

	c "github.com/relloyd/halfpipe/constants"
	log "github.com/relloyd/halfpipe/logger"
	"github.com/relloyd/halfpipe/stats"
	"github.com/relloyd/halfpipe/stream"
)

type DateRangeGeneratorConfig struct {
	Log                         log.Logger
	Name                        string
	InputChan                   chan stream.Record // input channel containing time.Time
	InputChanFieldName4FromDate string             // name of the field on InputChan which contains the FromDate values expected to be of type time.Time.
	InputChanFieldName4ToDate   string             // name of the field on InputChan which contains the ToDate values expected to be of type time.Time. This takes precedence over use of field ToDateRFC3339orNow.
	ToDateRFC3339orNow          string             // either supply "now" or a date in RFC3339 format which includes a time zone offset. If used, "now" will be truncated to the nearest second.
	UseUTC                      bool               // if true then the date generated by supplying "now" will be in UTC; else we expect local times.
	IntervalSizeSeconds         int                // number of seconds to split the duration between FromDate and ToDate into.
	OutputChanFieldName4LowDate string
	OutputChanFieldName4HiDate  string
	PassInputFieldsToOutput     bool
	StepWatcher                 *stats.StepWatcher
	WaitCounter                 ComponentWaiter
	PanicHandlerFn              PanicHandlerFunc
}

// NewDateRangeGenerator will:
// Read the input chan to get the FromDate(s).
// Figure out the ToDate (it could be "now").
// Calculate num intervals between FromDate and ToDate using the interval size in seconds.
// Output N rows of type date.
// Ensure daylight savings are accounted for.
func NewDateRangeGenerator(i interface{}) (outputChan chan stream.Record, controlChan chan ControlAction) {
	cfg := i.(*DateRangeGeneratorConfig)
	outputChan = make(chan stream.Record, c.ChanSize)
	controlChan = make(chan ControlAction, 1)
	if cfg.IntervalSizeSeconds == 0 {
		cfg.Log.Panic(cfg.Name, " aborting due to interval size 0 which causes infinite loop")
	}
	go func() {
		if cfg.PanicHandlerFn != nil {
			defer cfg.PanicHandlerFn()
		}
		cfg.Log.Info(cfg.Name, " is running")
		if cfg.WaitCounter != nil {
			cfg.WaitCounter.Add()
			defer cfg.WaitCounter.Done()
		}
		rowCount := int64(0)
		if cfg.StepWatcher != nil { // if we have been given a StepWatcher struct that can watch our rowCount and output channel length...
			cfg.StepWatcher.StartWatching(&rowCount, &outputChan)
			defer cfg.StepWatcher.StopWatching()

		}
		// Build the ToDate.
		var toDate time.Time
		var err error
		if cfg.InputChanFieldName4ToDate == "" && cfg.ToDateRFC3339orNow == "" { // if both possible toDates are missing...
			cfg.Log.Panic(cfg.Name, " set one of InputChanFieldName4ToDate or a literal in ToDateRFC3339orNow")
		}
		if cfg.InputChanFieldName4ToDate == "" { // if we have NOT been given a field name to fetch the toDate from...
			// Now we expect a literal in ToDateRFC3339orNow.
			if regexp.MustCompile(`(?i)(now)`).MatchString(cfg.ToDateRFC3339orNow) { // if we need to fetch Now for the ToDate...
				toDate = time.Now().Truncate(time.Second) // now to the nearest second
			} else { // else we need to parse the ToDate received...
				toDate, err = time.Parse(time.RFC3339, cfg.ToDateRFC3339orNow)
				if err != nil {
					cfg.Log.Panic(err)
				}
			}
		}
		if cfg.UseUTC {
			toDate = toDate.UTC()
		}
		// Iterate over the input records.
		sendRow := func(inputRec stream.Record, fromDate *time.Time, toDate *time.Time) (rowSentOK bool) {
			// Emit low date and hi date record.
			rec := stream.NewRecord()
			if cfg.PassInputFieldsToOutput {
				inputRec.CopyTo(rec) // ensure the output record contains the input fields.
			}
			rec.SetData(cfg.OutputChanFieldName4LowDate, *fromDate)
			rec.SetData(cfg.OutputChanFieldName4HiDate, *toDate)
			rowSentOK = safeSend(rec, outputChan, controlChan, sendNilControlResponse) // forward the record
			if rowSentOK {
				cfg.Log.Debug(cfg.Name, " generated: lowDate=", *fromDate, "; highDate=", *toDate)
			}
			return
		}
		select {
		case controlAction := <-controlChan: // if we have been asked to shutdown...
			controlAction.ResponseChan <- nil // respond that we're done with a nil error.
			cfg.Log.Info(cfg.Name, " shutdown")
			return
		case rec, ok := <-cfg.InputChan: // for each FromDate record...
			if !ok { // if the input chan was closed...
				cfg.InputChan = nil // disable this case.
			} else {
				// Get the toDate.
				if cfg.InputChanFieldName4ToDate != "" {
					var castOK bool
					toDate, castOK = rec.GetData(cfg.InputChanFieldName4ToDate).(time.Time)
					if !castOK {
						cfg.Log.Panic(cfg.Name, " unexpected datatype for input field name ", cfg.InputChanFieldName4ToDate, ", expected time.Time")
					}
				}
				cfg.Log.Info(cfg.Name, " splitting date range ", rec.GetData(cfg.InputChanFieldName4FromDate), " to ", toDate, " using interval ", cfg.IntervalSizeSeconds, " seconds")
				// Get the FromDate.
				fromDate, err := getTimeFromInterface(rec.GetData(cfg.InputChanFieldName4FromDate))
				if err != nil {
					cfg.Log.Panic(cfg.Name, " error - ", err)
				}
				// Add the increment and emit rows until it is greater than the ToDate.
				for { // while we are outputting less than ToDate...
					to := fromDate.Add(time.Second * time.Duration(cfg.IntervalSizeSeconds))
					if to.After(toDate) { // if this increment overruns the max date...
						break // don't output a row!
					}
					if rowSentOK := sendRow(rec, &fromDate, &to); !rowSentOK {
						return
					}
					atomic.AddInt64(&rowCount, 1) // increment the row count bearing in mind someone else is reporting on its values.
					fromDate = to                 // save FromDate with increment added.
				}
				if fromDate.Before(toDate) || atomic.AddInt64(&rowCount, 0) == 0 {
					// if we have a final portion of time time to output a row for;
					// or we have not output a row (i.e. when min value = max value)...
					if rowSentOK := sendRow(rec, &fromDate, &toDate); !rowSentOK { // emit the final gap.
						return
					}
					atomic.AddInt64(&rowCount, 1) // add a row count.
				}
			}
			if cfg.InputChan == nil { // if we processed all data...
				break // end gracefully.
			}
		}
		// Calculate output.
		close(outputChan)
		cfg.Log.Info(cfg.Name, " complete")
	}()
	return
}

func getTimeFromInterface(input interface{}) (t time.Time, err error) {
	switch input.(type) {
	case time.Time:
		t = input.(time.Time)
	default:
		err = fmt.Errorf("unexpected data type during conversion - expected Time, got: %v; value=%v", reflect.TypeOf(input), input)
	}
	return
}
