package components

import (
	"testing"
	"time"

	c "github.com/relloyd/halfpipe/constants"
	"github.com/relloyd/halfpipe/rdbms/shared"
	"github.com/relloyd/halfpipe/stream"
	"github.com/sirupsen/logrus"
)

func TestNewSqlExec(t *testing.T) {
	log := logrus.New()
	log.SetLevel(logrus.DebugLevel)

	// Test 1.
	log.Info("Test 1, confirm SqlExec will execute and sqlText is OK")
	db, mockDbConnChan := shared.NewMockConnectionWithMockTx(log, "mockDbType")
	inputChan := make(chan stream.Record, int(c.ChanSize))
	sqlQueryFieldName := "sqlText"
	rowsAffectedFieldName := "rowsAffected"
	sqlText := "select 1 from dual"
	// Add dummy rows to the channel...
	r1 := stream.NewRecord()
	r1.SetData("sqlText", sqlText)
	// Configure SqlExec.
	cfg := &SqlExecConfig{
		Log:                      log,
		Name:                     "Test SqlExec",
		InputChan:                inputChan,
		OutputDb:                 db,
		SqlQueryFieldName:        sqlQueryFieldName,
		SqlRowsAffectedFieldName: rowsAffectedFieldName, // TODO: add a test to check that a valid number of rows affected is generated by SqlExec, by using a proper database connection (at time of writing this is set to 1 by the mock)
	}
	// Start SqlExec.
	chanOutput, _ := NewSqlExec(cfg)
	inputChan <- r1
	idx := 0
	outputRows := make([]stream.Record, 0)
	resultList := make([]string, 0)
	close(inputChan)
	// Save the downstream output and record count.
	for rec := range chanOutput { // for each row executed by SqlExec...
		idx++
		log.Debug("output from SqlExec: idx = ", idx, "; data = ", rec)
		outputRows = append(outputRows, rec)
	}
	// Assert the number of rows output by SqlExec.
	expected := 1
	if idx != expected {
		t.Fatalf("expected %v rows output from SqlExec but got %v", expected, idx)
	}
	// Assert output sqlText is the same.
	got := outputRows[0].GetDataAsStringPreserveTimeZone(log, sqlQueryFieldName)
	if got != sqlText {
		t.Fatalf("expected sqlText %q but got %q", sqlText, got)
	}
	// Assert the rowsAffected field is added to the output stream.
	m := outputRows[0].GetDataMap()
	if _, ok := m[rowsAffectedFieldName]; !ok {
		t.Fatalf("expected rowsAffected field %q to exist in the SqlExec result", rowsAffectedFieldName)
	}
	// close mockDbConnChan and check it.
	db.Close()
	for str := range mockDbConnChan { // for each SQL query executed by the mock database...
		log.Debug("saving string from mockDbConnChan: ", str)
		resultList = append(resultList, str)
	}
	log.Debug("Asserting SQL...")
	assertStr(t, log, `select 1 from dual`, resultList[0])
	log.Info("Test 1 complete")

	// Test 2.
	log.Info("Test 2, confirm SqlExec shuts down")
	db2, _ := shared.NewMockConnectionWithMockTx(log, "mockDbType")
	inputChan2 := make(chan stream.Record, int(c.ChanSize))
	cfg.InputChan = inputChan2
	cfg.OutputDb = db2
	// Start the SqlExec with no input.
	_, controlChan := NewSqlExec(cfg)
	// Send shutdown request.
	responseChan := make(chan error, 1)
	controlChan <- ControlAction{ResponseChan: responseChan, Action: Shutdown} // send shutdown.
	// Wait for a response from TableSync to say it has shutdown.
	select {
	case <-time.After(3 * time.Second):
		t.Fatal("timeout waiting for SqlExec to shutdown")
	case <-responseChan: // if we get a shutdown response...
		// continue OK
	}
	log.Info("Test 2 complete")

	// Test 3 - rowsAffected can be omitted (test for its existence is above)
	log.Info("Test 3, confirm SqlExec allows the rowsAffected field to be omitted")
	db3, _ := shared.NewMockConnectionWithMockTx(log, "mockDbType")
	// Create new input data as r1 has been mutated.
	r3 := stream.NewRecord()
	r3.SetData("sqlText", sqlText)
	inputChan3 := make(chan stream.Record, 1)
	inputChan3 <- r3
	cfg.SqlRowsAffectedFieldName = "" // empty for this test.
	cfg.InputChan = inputChan3
	cfg.OutputDb = db3
	chanOutput3, _ := NewSqlExec(cfg)
	idx = 0
	outputRows3 := make([]stream.Record, 0)
	close(inputChan3)
	for rec3 := range chanOutput3 { // for each row executed by SqlExec...
		log.Debug("output from SqlExec: idx = ", idx, "; data = ", rec3)
		outputRows3 = append(outputRows3, rec3)
	}
	// Assert the rowsAffected field is NOT added to the output stream.
	m3 := outputRows3[0].GetDataMap()
	if _, ok := m3[rowsAffectedFieldName]; ok {
		t.Fatalf("expected field %q to NOT exist in the SqlExec result", rowsAffectedFieldName)
	}
	log.Info("Test 3 complete")
}
